\input{../../latex/preamble}
\input{../../latex/format}
\input{../../latex/commands}

\begin{document}

\begin{Large}
    \textbf{PRG22105 --- Programação de Computadores II}
    
    Projeto \hfill \lang{blabla}{\DAY~de \MONTH~de \YEAR}
\end{Large}

\vspace{1ex}
\textbf{\lang{Lecturer:}{Professor:}} \text{João Cláudio Elsen Barcellos}, \href{mailto:joao.barcellos@ifsc.edu.br}{\texttt{joao.barcellos@ifsc.edu.br}}\\
\textbf{\lang{Student:}{Estudante:}}


\vspace{2ex}
\begin{problem}{Controlador para produção de cerveja artesanal}{interpretacao}

\textbf{Objetivo e visão geral:} Este projeto propõe o desenvolvimento de um sistema embarcado para auxiliar no processo de produção de cerveja artesanal. O sistema deve controlar, em tempo real, a temperatura do processo e acionar a agitação do mosto por meio de um mixer, conforme condições específicas. Para isso, devem ser empregadas técnicas de controle como PID ou ON/OFF com histerese. As decisões de controle devem se basear em curvas programáveis (temperatura versus tempo), que podem ser definidas pelo usuário ou pré-configuradas no sistema.\\ 

A lógica de controle pode ser implementada a partir de uma máquina de estados gerada automaticamente com a ferramenta Yakindu (atualmente chamada itemis CREATE), ou construída manualmente pelo aluno. Nos casos em que Yakindu for utilizado, espera-se que os métodos da interface gerada sejam corretamente implementados no código-fonte. Caso o aluno opte por construir a máquina de estados do zero, o sistema deverá ser estruturado usando conceitos de orientação a objetos em C++, com destaque para o uso de métodos virtuais e polimorfismo. Nessa abordagem, o sistema deve permitir uma versão embarcada (ESP32) e outra versão simulável no PC, com troca de implementações via herança ou composição polimórfica. O sistema, como um todo, é apresentado de forma sucinta na \autoref{fig:diagrama-cerveja}.\\

\vspace{1ex}
\textbf{Requisitos mínimos:}
\begin{enumerate}
    \item \textbf{Plataforma de controle:}
    \begin{itemize}
        \item Microcontrolador de 32 bits com suporte a I\textsuperscript{2}C, SPI e UART.
        \item Capacidade de operação em tempo real (bare-metal ou com RTOS).
    \end{itemize}

    \item \textbf{Sensores e atuações:}
    \begin{itemize}
        \item Leitura de temperatura via I\textsuperscript{2}C.
        \item Controle de resistências (heaters) via GPIO ou PWM.
        \item Controle de mixer via GPIO ou PWM.
    \end{itemize}

    \item \textbf{Controle:}
    \begin{itemize}
        \item Implementação de controle PID e/ou ON/OFF com histerese.
        \item Mixer deve ser ativado quando a diferença entre dois sensores de temperatura exceder \SI{1}{\degreeCelsius}.
    \end{itemize}

        \item \textbf{Máquina de estados:}
    \begin{itemize}
        \item A máquina de estados pode ser gerada com o Yakindu/itemis CREATE, com implementação dos métodos obrigatórios da interface.
        \item Alternativamente, o controle pode ser implementado manualmente em C++, desde que use métodos virtuais, polimorfismo e permita a simulação no PC.
        \item A versão simulada deve permitir que a lógica de decisão seja testada sem o hardware, via entradas simuladas e saídas controladas por abstrações.
    \end{itemize}

    \item \textbf{Curvas programáveis:}
    \begin{itemize}
        \item O sistema deve possuir uma curva padrão.
        \item Novas curvas podem ser inseridas via comunicação serial.
        \item As curvas devem descrever um perfil de temperatura em função do tempo.
    \end{itemize}

    \item \textbf{Interfaces:}
    \begin{itemize}
        \item Interfaces lógicas: GPIO, PWM, I\textsuperscript{2}C, UART.
        \item Comunicação com o PC via UART.
    \end{itemize}

    \item \textbf{Detecção de erros:}
    \begin{itemize}
        \item O sistema deve identificar falhas como ausência de leitura dos sensores.
        \item Deve alertar o usuário e desativar os atuadores para segurança.
    \end{itemize}

    \item \textbf{Documentação e repositório:}
    \begin{itemize}
        \item Projeto deve estar versionado em repositório GitHub.
        \item Recomenda-se uso de \texttt{Doxygen} para documentação do código.
    \end{itemize}

    \item \textbf{Funcionalidade adicional:}
    \begin{itemize}
        \item O estudante deve propor e implementar uma funcionalidade extra, como: alarme sonoro, registro de logs, visualização gráfica, modo de calibração, entre outros.
    \end{itemize}
\end{enumerate}

\vspace{1ex}
\textbf{Sugestão de entregas parciais:}
\begin{description}
    \item[Entrega 1:] Levantamento de requisitos, definição das curvas, modelagem da máquina de estados (manual ou Yakindu) e diagramas de sistema.
    \item[Entrega 2:] Implementação dos drivers de sensores e atuadores, controle básico (PID ou ON/OFF), e comunicação com o PC.
    \item[Entrega 3:] Integração final com mixer funcional, detecção de falhas, funcionalidade adicional, documentação completa e demonstração.
\end{description}

\vspace{1ex}
\textbf{Critérios de avaliação:}
\begin{itemize}
    \item Funcionamento dos módulos implementados
    \item Clareza e organização do código
    \item Uso de boas práticas de programação embarcada
    \item Qualidade da documentação
    \item Utilização efetiva do GitHub para controle de versão
\end{itemize}

\vspace{1ex}
\textbf{Observações:}
\begin{itemize}
    \item A implementação pode ser feita em C ou C++ (preferencialmente, C++).
    \item O sistema deve ser portável e preparado para execução em plataforma embarcada real (ESP32 ou equivalente).
    \item É permitida a simulação parcial de dispositivos, desde que devidamente descrita e justificada.
    \item A lógica de controle deve ser validável tanto em ambiente embarcado quanto em simulação no PC.
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[thick]

% --- Blocos principais ---
\node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (sensor) at (0,0) {Sensor de Temp.};
\node[draw, rectangle, minimum width=3cm, minimum height=1.5cm, align=center] (uC) at (4,0) {Microcontrolador\\(PID + UI)};
\node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (res) at (8,1.5) {Resistência};
\node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (mixer) at (8,-1.5) {Mixer};
\node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (lcd) at (4,2.5) {LCD 4x16};
\node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (btn) at (4,-2.5) {Botões};
\node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (esp) at (4,-4.5) {ESP32 (UART)};
\node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (pc) at (8,-4.5) {PC (Interface)};

% --- Setas ---
\draw[->] (sensor) -- (uC);
\draw[->] (uC) -- (res);
\draw[->] (uC) -- (mixer);
\draw[->] (uC) -- (lcd);
\draw[->] (btn) -- (uC);
\draw[<->] (esp) -- (pc);
\draw[->] (uC) -- (esp);

% --- Curva de temperatura padrão no canto superior direito ---
\begin{scope}[xshift=10cm, yshift=3cm, scale=0.8]
\begin{axis}[
    width=5cm,
    height=4cm,
    xmin=0, xmax=9,
    ymin=50, ymax=100,
    axis lines=middle,
    axis line style={->, thick},
    tick style={draw=none},
    xtick=\empty, ytick=\empty,
    xlabel={\small Tempo},
    ylabel={\small Temp.},
    title={Curva Padrão},
    title style={font=\small}
]

% Curva com três platôs
\addplot[very thick, blue, mark=none] coordinates {
    (0,67) (3,67)
    (3,78) (6,78)
    (6,90) (9,90)
};

% Anotações acima dos degraus
\node[anchor=south] at (axis cs:1.5,67) {\footnotesize 67\( ^\circ \)C};
\node[anchor=south] at (axis cs:4.5,78) {\footnotesize 78\( ^\circ \)C};
\node[anchor=south] at (axis cs:7.5,90) {\footnotesize Max.};

\end{axis}
\end{scope}



\end{tikzpicture}
\caption{\textcolor{red}{FIXME:} Diagrama geral do sistema de controle com curva padrão de temperatura.}
\label{fig:diagrama-cerveja}
\end{figure}


    
\end{problem}
    
\newpage

\vfill
\printbibliography

\end{document}
